@using SharpIDE.Application.Features.SolutionDiscovery
@using SharpIDE.Photino.Services

@inject RefreshOpenFileService RefreshOpenFileService

<MudText>
	@Path.GetFileName(FilePath)
	@if (_unsavedEdits)
	{
		<span>*</span>
	}
</MudText>
<style>
	#my-editor-id {
		height: calc(100vh - 100px);
	}
</style>
<StandaloneCodeEditor @ref="_codeEditorRef" Id="my-editor-id" ConstructionOptions="@EditorConstructionOptions" OnDidChangeModelContent="IfDirtyMarkDirty" OnDidBlurEditorText="@SaveFileToDisk" />

@code {
	[Parameter, EditorRequired]
    public string FilePath { get; set; } = null!;

	[Parameter, EditorRequired]
	public SharpIdeFile? SelectedFile { get; set; }

	private string? _fileContent;
	private bool _unsavedEdits = false;

	StandaloneCodeEditor _codeEditorRef = null!;

	private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
	{
		return new StandaloneEditorConstructionOptions
		{
			AutomaticLayout = true,
			Language = "csharp",
			Theme = "vs-dark",
			ScrollBeyondLastLine = false,
			FontSize = 18,
			Value = _fileContent
		};
	}

	protected override async Task OnInitializedAsync()
	{
		await ReadFile();
		RefreshOpenFileService.RefreshOpenFile += async () =>
		{
			Console.WriteLine("RefreshOpenFileService.RefreshOpenFile called");
			await ReadFile();
			var model = await _codeEditorRef.GetModel();
			ArgumentNullException.ThrowIfNull(model);
			await model.SetValue(_fileContent);
			StateHasChanged();
		};
	}

	private async Task ReadFile()
	{
		var fileInfo = new FileInfo(FilePath);
		if (!fileInfo.Exists)
		{
			throw new FileNotFoundException($"File not found: {FilePath}");
		}
		var fileContent = await File.ReadAllTextAsync(FilePath);
		_fileContent = fileContent;
	}

	private async Task SaveFileToDisk(object obj)
	{
		if (_unsavedEdits is false)
		{
			return;
		}
		var editor = obj as StandaloneCodeEditor;
		ArgumentNullException.ThrowIfNull(editor, nameof(editor));
		var editorTextValue = await editor.GetValue();
		await File.WriteAllTextAsync(FilePath, editorTextValue);
		_fileContent = editorTextValue;
		_unsavedEdits = false;
	}

	private async Task IfDirtyMarkDirty()
	{
		// Probably quite non-performant
		if (await _codeEditorRef.GetValue() != _fileContent)
		{
			_unsavedEdits = true;
		}
		else
		{
			_unsavedEdits = false;
		}
	}
}
